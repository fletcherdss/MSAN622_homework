<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Project Prototype</title>
    <script type="text/javascript" src="js/d3.min.js"></script>
    <script type="text/javascript" src="js/underscore-min.js"></script>
    <script type="text/javascript" src="js/project.js"></script>
    <script type="text/javascript" src="d3.slider/d3.slider.js"></script>
</head>


<link rel="stylesheet" href="d3.slider/d3.slider.css" />  
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  position: relative;
  width: 960px;
}

.axis { font: 13px sans-serif; }

.axis path,
.axis line {
  fill: #FFFFFF;
  stroke: black;
  shape-rendering: crispEdges;
}

.x.axis path {display: none;}
.y.axis path {display: black;}
.y.axis .tick line {stroke: lightgrey;}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 2.5px;
}

.center {
  position: relative;
  top: 350px;
  left: 1360px;
}

.trim {
  position: relative;
  top: 380px;
  left: 1241px;
}

.verticalBar {
  position: relative;
  top: 410px;
  left: 1083px;
}

 #slider4 {
     height: 250px;
     position: relative;
     top: 432px;
     left: 1360px;
 }

 #slider4text {
     height: 250px;
     position: relative;
     top: 428px;
     left: 976px;
 }



</style>

<body>


<title>Project Prototype</title>

<link href="css/bootstrap.min.css" rel="stylesheet">
<link href="css/bootstrap-theme.min.css" rel="stylesheet">

<style type="text/css">
    body {
        padding-top: 50px;
        padding-bottom: 20px;
    }
</style>


<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
		<button type="button" class="navbar-toggle collapsed" 
		    data-toggle="collapse" data-target="#navbar" 
		    aria-expanded="false" aria-controls="navbar">
			<span class="sr-only">Toggle Navigation</span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="./#">MSAN 622</a>
        </div>
	
        <div id="navbar" class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="./#homework">Homework</a></li>
			<li><a href="./#project">Project</a></li>
			<li><a href="./#participation">Participation</a></li>
		</ul>
		
		<ul class="nav navbar-nav navbar-right">
			<li><a href="./#about">About</a></li>
			<li><a href="./#contact">Contact</a></li>
		</ul>
        </div><!--/.nav-collapse -->
    </div>
</nav> 


<label class ="center"><input type="checkbox"> Center Groups</label>
<label class ="trim"><input type="checkbox"> End on Last Mention</label> 
<label class ="verticalBar"><input type="checkbox"> Vertical Bars</label> 
<span id="slider4text">Page Size: 60 lines</span><
<div id="slider4"></div>


<script>

 var margin = {top: 20, right: 20, bottom: 40, left: 150},
     width = 1300 - margin.left - margin.right,
     height = 900 - margin.top - margin.bottom,
     heightFlow = 500, 
     heightBar = height - heightFlow, widthBar = 500;

 function makeAxies(svg, x, y, group){
     var xAxis = d3.svg.axis().scale(x).orient("bottom").tickSize(6, 0 , 0);
     xAxis.tickFormat(d3.format("d"));
     var yAxis = d3.svg.axis().scale(y).orient("left").tickSize(6, 0, 0);
     
     var xax = svg.append("g").attr("class", group)
                  .attr("transform", "translate(0," + y.range()[0] + ")")
	              .call(xAxis.ticks(15));
     
     xax.append("text")
	    .attr("y", 36)
	    .attr("x", (x.range()[1] + x.range()[0]) / 2 - 50)
	    .attr("dx", "0.71em")
	    .style("text-anchor", "end", " grid")
	    .text("page");
 };

 var svg = d3.select("body").append("svg")
	          .attr("width", width + margin.left + margin.right)
	          .attr("height", height + margin.top + margin.bottom)
	          .append("g")
	          .attr("transform",
                    "translate(" + (margin.left) + "," + (margin.top) + ")");

 //An object for keeping track of the interative features and handling updates
 var state = {trim:false, center:false, pageSize:60}

 state.setScales = function () {
     st = this;
     st.x = d3.scale.linear()
               .domain(d3.extent(st.paths[st.chars[0]], function(d) {return d.page;}))
               .range([0,width]);
     console.log(st.x.domain());
     
     st.y = d3.scale.linear()
               .domain([0, st.chars.length + 1])
               .range([heightFlow, 0]);
     
     st.color = d3.scale.category10()
                   .domain(st.chars);

     st.xb = d3.scale.ordinal().domain(st.chars).rangeRoundBands([0, widthBar]);
     st.yb = d3.scale.linear()
                  .domain([0, d3.max(_.values(st.bins))])
                  .range([height, heightFlow + 40]);

     st.yhb = d3.scale.ordinal().domain(st.chars)
                   .rangeRoundBands([height, height - heightBar + 40]);
     st.xhb = d3.scale.linear()
                  .domain([0, d3.max(_.values(st.bins))])
                  .range([0, widthBar]);

     st.xc = d3.scale.linear().domain(st.x.domain()).range([widthBar, width]);
     st.yc = d3.scale.linear().domain([0, 1]).range([height, heightFlow + 40]);
 }

 state.update = function (paths) {
     st = this
     chars = st.chars
     drawLines(st, st.paths);
     d3.select(".center").select("input").on("change", function() {
         state.center = this.checked;
         drawLines(st, st.paths);
     });
     d3.select(".trim").select("input").on("change", function() {
         state.trim = this.checked; 
         drawLines(st, st.paths);
     });
     d3.select(".verticalBar").select("input").on("change", function() {
         state.verticalBar = this.checked; 
         state.yhb.domain(state.chars)
         drawBars(state, state.bins);
     });
     d3.select('#slider4').call(
         d3.slider().value(state.pageSize).min(8).max(80)
           .orientation("vertical").on("slide", function(evt, value) {
               st.pageSize = Math.floor(value);
               d3.select('#slider4text').text("Page Size: " + st.pageSize + " lines");
               st.paths = builtCompletePaths(st.pageSize, st.chars, st.rawData);
               st.cumulativeData = cumulativeSum(st.chars, st.rawData, st.pageSize);
               st.setScales();
               drawLines(st, st.paths);
               drawCumulative(st);
         }));
 }

 d3.json("data/blackar.txt", function (rawData) {
     state.rawData = rawData;
     state.bins = _.countBy(_.flatten(rawData), _.identity);
     state.chars = getKLargestKeys(state.bins);
     state.cumulativeData = cumulativeSum(state.chars, rawData, state.pageSize);
     state.paths = builtCompletePaths(state.pageSize, state.chars, rawData);     
     var paths = state.paths;

     state.setScales(paths);
     drawCumulative(state)
     state.update(paths);
     drawHBars(state, state.bins);
 });

 function drawBars(state, bins) {
     d3.select(".bars").remove();
     if (state.verticalBar)
         drawVBars(state, bins)
     else
         drawHBars(state, bins)
 }

 function drawVBars(state, bins) {
     var bars = svg.append('g').attr("class", "bars");
     state.chars.forEach(function(character) {
         var r = bars.append('rect').datum(bins[character]);
         r.attr('y', function (d) {return state.yb(d);})
		  .attr('x', state.xb(character))
          .attr('height',function (d) {return height - state.yb(d);})
          .attr('width', widthBar / state.chars.length - 10)
          .attr('fill', state.color(character));
     });
 } 

 function drawHBars(state, bins) {
     var bars = svg.append('g').attr("class", "bars");
     var barsize = heightBar / state.chars.length
     state.chars.forEach(function(character) {
         var r = bars.append('rect').datum(bins[character]);
         r.attr('y', state.yhb(character))
		  .attr('x', 0)
          .attr('width',function (d) {return state.xhb(d);})
          .attr('height', barsize - 10)
          .attr('fill', state.color(character));
         bars.append("text")
	      .attr("y", state.yhb(character) + barsize/2 )
	      .attr("x", -35)
	      .attr("dx", "0.71em")
	      .style("text-anchor", "end")
          .attr("fill", state.color(character))
	      .text(character);

     });
 } 


 function drawCumulative(state) {
     var cumulative = state.cumulativeData;
     var line = d3.svg.line()
                  .x(function(d) {return state.xc(d.page); })
                  .y(function(d) {return state.yc(d.count / state.bins[d.name]); })
                  .interpolate("monotone");
     svg.select(".cumulative").remove();
     var cLines = svg.append('g').attr("class", "cumulative")
     state.chars.forEach(function(character) {
         cLines = cLines.datum(cumulative[character]);
         cLines.append("path")
          .attr("class", "line")
          .attr("d", line)
          .style("stroke", function(d) { return state.color(character); });
     });

     makeAxies(cLines, state.xc, state.yc, "group");
 };
  

 function drawLines(state) {
     var chars = state.chars;
     var x = state.x, y = state.y, color = state.color;
     var c = state.center ? -1 : 0;
     var flatpath = flattenPaths(chars, state.paths);
     var pths = state.paths;

     ypos = function(d) {
         return y(groupNumber(d.char, d.page, state.paths, chars, c)) -
         5 * _(flatpath[d.page]).indexOf(d.char); 
     }

     if (state.trim) {
         var trimmedPaths = {}
         chars.forEach(function(c) {trimmedPaths[c] = trimPath(pths[c]);})
         pths = trimmedPaths;
     }
     
     var line = d3.svg.line()
                  .x(function(d) { return x(d.page); })
                  .y(ypos)
                  .interpolate("monotone");

     svg.select(".x_axis_lines").remove();
     makeAxies(svg, state.x, state.y, "x_axis_lines");
     
     chars.forEach(function(char) {
         svg.select("." + char.replace(/\s/g, '_')).remove();
         path = [{'char':char, page:0, present:false}].concat(pths[char]);
         l = svg.append("g").attr("class", char.replace(/\s/g, '_'))
                .datum(path);
         l.append("path")
          .attr("class", "line")
          .attr("d", line)
          .style("stroke", function(d) { return color(char); });
//          .style("stroke-dasharray", function(d) { return  d.present ? none : [3,3]; });

         l.append("text")
	      .attr("y", ypos(path[0]) + 3)
	      .attr("x", -35)
	      .attr("dx", "0.71em")
	      .style("text-anchor", "end")
          .attr("fill", color(char))
	      .text(char);

     });
  }




</script>


<div class="row">
    <div class="col-md-10">
        <h2 class="page-header"><a name="about"></a>Techniques</h2> 
            <div class="media-body">
                <p>
                    The primary plot is a visulation of which charactes are present
                    (mentioned by name) in works of fiction. The inspiration of 
                    this plot was a graph from <a href="https://xkcd.com/657/large/"> XKCD </a>. 
                    The XKCD graph shows 
                    presence of characters by time in various movies. It would be impossible
                    to determine simultaneous events just from reading a book, so instead
                    the graph shows what pages characters are mentioned on and when 
                    multiple characters are on the same page. By default a page is 60 lines
                    but the page size is adjustable with the slider.
                </p>

                <p>
                    The top graph only show if a character is mentioned, not how often.
                    I included two more graphs to supply that information. One can 
                    quickly glean that Richard Shelton is the protagonist of this book from
                    the next two graphs. 
                </p>

                <p>
                    The first graph is a simple bar graph, showing the total number 
                    of times each character is mentioned. As you can see this praticalar book
                    has a single protagonist. The other characters are mentioned by 
                    name much less often. 
                </p>

                <p>
                    The second graph is a cumulative percentage graph. It 
                    becomes even more apperant that Richard Shelton is a central 
                    character as he occurs uniformly throughout the book. It also
                    is appearant the Sir Daniel plays a central role.
                    By contrast Bennet Hatch is mentioned mostly in the begining and so is 
                    less central to the story. 

                </p>

                <p>
                    


                </p>
                
            </div>

    </div>

    <div class="col-md-10">
        <h2 class="page-header"><a name="about"></a>Interactivity</h2> 
            <div class="media-body">
                <p>
                    There are several forms of interactivity. The primary
                    form of interactivity is the the adjustable page size. 
                    Adjusting the size of pages with the slider allows the user 
                    to strike a balance between readability and Lie Factor. If 
                    the page size is small then Lie Factor is low, while if the 
                    page size is large then the lie factor is high. Setting the page
                    size high is preferable if the user is trying to get a
                    big picture of the flow of the story, while a smaller page size 
                    allows them to see to details of when characters are mentioned. 
                </p>

                <p>
                    Zooming by a brush/slider is/was planned but it may or may not be 
                    completed by midnight tonight. Zooming allows the user to 
                    focus on specific sections of the action, and is a complement
                    to adjusting page size. 
                </p>

                <p>
                    Filtering by character is/was also planned. As with zooming 
                    filtering allows the users to focus, but this time by character 
                    rather than page. Filtering allows users to investigate questions 
                    like how often specific characters occur togeather. 
                </p>

                <p>
                     The
                    User also has the option to put the grouped users either at the bottom of 
                    the graph or at the median of their starting positions. The former option
                    encodes more information as it enables the users to recogize when
                    only a single character is present. Also centering does risk having
                    users appear to be present if their starting postion is in the center of the
                    group. Centering does look a lot better though, and significantly reduces
                    the amount of crossing lines. 
                    It was planned to have the user be able to manually move the lines
                    to further reduce clutter, but there wasn't time to implement this feature. 
                </p>

                <p>
                    The User also has the option of having lines end once a character is no longer 
                    mentioned. This does not produce a very dramatic effect for this
                    visualization, and not many of the main characters are killed
                    or removed from action, or if they are they might still be
                    mentioned again. This could be interesting for visualizing a work like Game 
                    of Thrones though.
                </p>
                
            </div>

    </div>

    <div class="col-md-10">
        <h2 class="page-header"><a name="featuresc"></a> Feedback </h2>
        <div class="media-body">
            <p>
                The main feedback I considered was having the characters end 
                when the lines end. I elected to allow the user decide in this case,
                as the effect this will have depends a lot on the data. I has 
                had the sugestion to have absent characters be a faded color or a dashed line.
                I would have liked to implement this feature, but I did not have time to
                do so.

            </p>
        </div>
    </div>

    <div class="col-md-10">
        <h2 class="page-header"><a name="featuresc"></a> Challanges </h2>
        <div class="media-body">
            <p>
                The biggest challege for this project was just handling the data. 
                Stripping the words out of the text proved to be pretty straight forward.
                All I had to do get the list of characters from wikipedia 
                <a href="https://en.wikipedia.org/wiki/The_Black_Arrow:_A_Tale_of_the_Two_Roses#Characters"> Wikipedia </a>,
                add in a few alternative names for each character, and filter everything
                that wasn't a character name from each line. I wrote a simple python script
                which handled all that output everything in a JSON compliant text files
                <a href="https://github.com/fletcherdss/MSAN622_homework/blob/gh-pages/data/blackar.txt"> blackar.txt </a>.
            </p>
            <p>
                Getting the data into a form which could be used by d3 proved to be more difficult.
                The raw data was quite hetrogenious. I created a javascript library 
                <a href="https://github.com/fletcherdss/MSAN622_homework/blob/gh-pages/js/project.js"> project.js </a>
                which took significantly more time than I anticiptated. Javascript
                will often fail silently which meant it often took a while to get
                to the root of the problem. I can see moving forward that extensive 
                testing frameworks are necessary for any sort of javascript
                development, as often my data would fail to meet the specification
                I thought it had. 
                
            </p>
        
            <p>
                This was my first major javascript project, so there was
                still a fair amount of familiarizing myself with the language I
                had to do. Much of the functionality I was accustomed to with
                other languages doesn't exist in Javascript though I
                found <a href="http://underscorejs.org/"> Underscore </a> to 
                be a big help filling in a lot of the features I am was looking for.

            </p>

            <p>
                Finally I found handling updating in D3 to be tricky. While it
                might be fairly straight forward to put togeather a static 
                page, as soon as you need to flexibility in what is displayed things start
                to break. 

            </p>

        </div>
    </div>


    <div class="col-md-10">
        <h2 class="page-header"><a name="featuresc"></a> Summary </h2>
        <div class="media-body">
            <p>
                Each line represents a character. If two lines are near to each other
                in a certain page interval 
                that indicates that that they are both being mentioned on those pages.
                Currently being at the bottom of the graph indicates those 
                characters are being mentioned, while being away from the bottom
                indicates that they not being mentioned. I plan to have
                the characters not currently in the action be shown as
                dashed lines, but that has not implemented yet.
            </p>
            <p>
                The toggle box in the corner moves the characters currently
                present towards the middle, making the lines less tangled. 
                This presently this is somewhat confusing as the red line,
                appears to be present with the other characters 
                when in fact it is merely happens to lie in the center. 
                I plan to have move the characters not presently being mentioned away
                from those that are, but that has not yet been implemented.
            </p>
            <p>
                The plot shown is the top plot on the <a href="./projectsketch.html"> 
                original sketch </a>. It has remained true to it's original purpose,
                though some of the functionality shown has not yet been implemented.
                The bottom plots might change slightly. The bar plot will
                probably made specific to character names, and the line plot may be
                counts of character name by chapter.
                
            </p>
            
        </div>
    </div>
</div>

</body>
