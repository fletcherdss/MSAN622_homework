<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Project Prototype</title>
    <script type="text/javascript" src="js/d3.min.js"></script>
    <script type="text/javascript" src="js/underscore-min.js"></script>
    <script type="text/javascript" src="js/project.js"></script>
    <script type="text/javascript" src="d3.slider/d3.slider.js"></script>
</head>


<link rel="stylesheet" href="d3.slider/d3.slider.css" />  
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  position: relative;
  width: 960px;
}

.axis { font: 13px sans-serif; }

.axis path,
.axis line {
  fill: #FFFFFF;
  stroke: black;
  shape-rendering: crispEdges;
}

.x.axis path {display: none;}
.y.axis path {display: black;}
.y.axis .tick line {stroke: lightgrey;}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 2.5px;
}

.center {
  position: relative;
  top: 90px;
  right: -1360px;
}

.trim {
  position: relative;
  top: 120px;
  right: -1241px;
}

.verticalBar {
  position: relative;
  top: 150px;
  right: -1148px;
}

 #slider4 {
     height: 150px;
     position: relative;
     top: 160px;
     right: -1380px;
 }



</style>

<body>


<title>Project Prototype</title>

<link href="css/bootstrap.min.css" rel="stylesheet">
<link href="css/bootstrap-theme.min.css" rel="stylesheet">

<style type="text/css">
    body {
        padding-top: 50px;
        padding-bottom: 20px;
    }
</style>


<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
		<button type="button" class="navbar-toggle collapsed" 
		    data-toggle="collapse" data-target="#navbar" 
		    aria-expanded="false" aria-controls="navbar">
			<span class="sr-only">Toggle Navigation</span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
		<a class="navbar-brand" href="./#">MSAN 622</a>
        </div>
	
        <div id="navbar" class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="./#homework">Homework</a></li>
			<li><a href="./#project">Project</a></li>
			<li><a href="./#participation">Participation</a></li>
		</ul>
		
		<ul class="nav navbar-nav navbar-right">
			<li><a href="./#about">About</a></li>
			<li><a href="./#contact">Contact</a></li>
		</ul>
        </div><!--/.nav-collapse -->
    </div>
</nav> 


<label class ="center"><input type="checkbox"> Center Groups</label>
<label class ="trim"><input type="checkbox"> Trim Paths</label> 
<label class ="verticalBar"><input type="checkbox"> Vertical Bars</label> 
<div id="slider4"></div>


<script>


 var margin = {top: 20, right: 20, bottom: 40, left: 150},
     width = 1300 - margin.left - margin.right,
     height = 900 - margin.top - margin.bottom,
     heightFlow = 500, 
     heightBar = height - heightFlow, widthBar = 500;

 function makeAxies(svg, x, y, group){
     var xAxis = d3.svg.axis().scale(x).orient("bottom").tickSize(6, 0 , 0);
     xAxis.tickFormat(d3.format("d"));
     var yAxis = d3.svg.axis().scale(y).orient("left").tickSize(6, 0, 0);
     
     var xax = svg.append("g").attr("class", group)
                  .attr("transform", "translate(0," + y.range()[0] + ")")
	              .call(xAxis.ticks(15));
     
     xax.append("text")
	    .attr("y", 36)
	    .attr("x", (x.range()[1] + x.range()[0]) / 2 - 50)
	    .attr("dx", "0.71em")
	    .style("text-anchor", "end", " grid")
	    .text("page");
 };

 var svg = d3.select("body").append("svg")
	          .attr("width", width + margin.left + margin.right)
	          .attr("height", height + margin.top + margin.bottom)
	          .append("g")
	          .attr("transform",
                    "translate(" + (margin.left) + "," + (margin.top) + ")");

 //An object for keeping track of the interative features and handling updates
 var state = {trim:false, center:false, pageSize:40}

 state.setScales = function () {
     st = this;
     st.x = d3.scale.linear()
               .domain(d3.extent(st.paths[st.chars[0]], function(d) {return d.page;}))
               .range([0,width]);
     console.log(st.x.domain());
     
     st.y = d3.scale.linear()
               .domain([0, st.chars.length + 1])
               .range([heightFlow, 0]);
     
     st.color = d3.scale.category10()
                   .domain(st.chars);

     st.xb = d3.scale.ordinal().domain(st.chars).rangeRoundBands([0, widthBar]);
     st.yb = d3.scale.linear()
                  .domain([0, d3.max(_.values(st.bins))])
                  .range([height, heightFlow + 40]);

     st.yhb = d3.scale.ordinal().domain(st.chars)
                   .rangeRoundBands([height, height - heightBar + 40]);
     st.xhb = d3.scale.linear()
                  .domain([0, d3.max(_.values(st.bins))])
                  .range([0, widthBar]);

     st.xc = d3.scale.linear().domain(st.x.domain()).range([widthBar, width]);
     st.yc = d3.scale.linear().domain([0, 1]).range([height, heightFlow + 40]);
 }

 state.update = function (paths) {
     st = this
     chars = st.chars
     drawLines(st, st.paths);
     d3.select(".center").select("input").on("change", function() {
         state.center = this.checked;
         drawLines(st, st.paths);
     });
     d3.select(".trim").select("input").on("change", function() {
         state.trim = this.checked; 
         drawLines(st, st.paths);
     });
     d3.select(".verticalBar").select("input").on("change", function() {
         state.verticalBar = this.checked; 
         state.yhb.domain(state.chars)
         drawBars(state, state.bins);
     });
     d3.select('#slider4').call(
         d3.slider().value(state.pageSize).min(8).max(60)
           .orientation("vertical").on("slide", function(evt, value) {
               st.pageSize = Math.floor(value);
               st.paths = builtCompletePaths(st.pageSize, st.chars, st.rawData);
               st.cumulativeData = cumulativeSum(st.chars, st.rawData, st.pageSize);
               st.setScales();
               drawLines(st, st.paths);
               drawCumulative(st);
         }));
 }

 d3.json("data/blackar.txt", function (rawData) {
     state.rawData = rawData;
     state.bins = _.countBy(_.flatten(rawData), _.identity);
     state.chars = getKLargestKeys(state.bins);
     state.cumulativeData = cumulativeSum(state.chars, rawData, state.pageSize);
     state.paths = builtCompletePaths(state.pageSize, state.chars, rawData);     
     var paths = state.paths;

     state.setScales(paths);
     drawCumulative(state)
     state.update(paths);
     drawHBars(state, state.bins);
 });

 function drawBars(state, bins) {
     d3.select(".bars").remove();
     if (state.verticalBar)
         drawVBars(state, bins)
     else
         drawHBars(state, bins)
 }

 function drawVBars(state, bins) {
     var bars = svg.append('g').attr("class", "bars");
     state.chars.forEach(function(character) {
         var r = bars.append('rect').datum(bins[character]);
         r.attr('y', function (d) {return state.yb(d);})
		  .attr('x', state.xb(character))
          .attr('height',function (d) {return height - state.yb(d);})
          .attr('width', widthBar / state.chars.length - 10)
          .attr('fill', state.color(character));
     });
 } 

 function drawHBars(state, bins) {
     var bars = svg.append('g').attr("class", "bars");
     var barsize = heightBar / state.chars.length
     state.chars.forEach(function(character) {
         var r = bars.append('rect').datum(bins[character]);
         r.attr('y', state.yhb(character))
		  .attr('x', 0)
          .attr('width',function (d) {return state.xhb(d);})
          .attr('height', barsize - 10)
          .attr('fill', state.color(character));
         bars.append("text")
	      .attr("y", state.yhb(character) + barsize/2 )
	      .attr("x", -35)
	      .attr("dx", "0.71em")
	      .style("text-anchor", "end")
          .attr("fill", state.color(character))
	      .text(character);

     });
 } 


 function drawCumulative(state) {
     var cumulative = state.cumulativeData;
     var line = d3.svg.line()
                  .x(function(d) {return state.xc(d.page); })
                  .y(function(d) {return state.yc(d.count / state.bins[d.name]); })
                  .interpolate("monotone");
     svg.select(".cumulative").remove();
     var cLines = svg.append('g').attr("class", "cumulative")
     state.chars.forEach(function(character) {
         cLines = cLines.datum(cumulative[character]);
         cLines.append("path")
          .attr("class", "line")
          .attr("d", line)
          .style("stroke", function(d) { return state.color(character); });
     });

     makeAxies(cLines, state.xc, state.yc, "group");
 };
  

 function drawLines(state) {
     var chars = state.chars;
     var x = state.x, y = state.y, color = state.color;
     var c = state.center ? -1 : 0;
     var pths = state.paths;
     var flatpath = flattenPaths(chars, pths);

     if (state.trim) {
         var trimmedPaths = {}
         chars.forEach(function(c) {trimmedPaths[c] = trimPath(paths[c]);})
         pths = trimmedPaths;
     }
     
     ypos = function(d) {
         return y(groupNumber(d.char, d.page, pths, chars, c)) -
         5 * _(flatpath[d.page]).indexOf(d.char); 
     }

     var line = d3.svg.line()
                  .x(function(d) { return x(d.page); })
                  .y(ypos)
                  .interpolate("monotone");

     svg.select(".x_axis_lines").remove();
     makeAxies(svg, state.x, state.y, "x_axis_lines");
     
     chars.forEach(function(char) {
         svg.select("." + char.replace(/\s/g, '_')).remove();
         path = [{'char':char, page:0, present:false}].concat(pths[char]);
         l = svg.append("g").attr("class", char.replace(/\s/g, '_'))
                .datum(path);
         l.append("path")
          .attr("class", "line")
          .attr("d", line)
          .style("stroke", function(d) { return color(char); });
//          .style("stroke-dasharray", function(d) { return  d.present ? none : [3,3]; });

         l.append("text")
	      .attr("y", ypos(path[0]) + 3)
	      .attr("x", -35)
	      .attr("dx", "0.71em")
	      .style("text-anchor", "end")
          .attr("fill", color(char))
	      .text(char);

     });
  }




</script>


<div class="row">
    <div class="col-md-10">
        <h2 class="page-header"><a name="about"></a>The Data Set</h2> 
            <div class="media-body">
                <p>
	                The data is currently mocked up, but the final project is based
                    on data extracted from one or more actual books. The data consists
                    of names of characters and where that characters name is mentioned in
                    the book. The data it self is sparsified. For each character There
                    are records marking the start and end of sections where that character
                    is mentioned frequently. You can see the full details of the
                    <a href="./projectdata.html"> Project Gutenberg  
                        data set </a>. The data set has not
                    changed, though I might be using a smaller portion than before and focusing
                    exclusively on fiction.
                </p>

                
            </div>

    </div>

    <div class="col-md-10">
        <h2 class="page-header"><a name="featuresc"></a> Summary </h2>
        <div class="media-body">
            <p>
                Each line represents a character. If two lines are near to each other
                in a certain page interval 
                that indicates that that they are both being mentioned on those pages.
                Currently being at the bottom of the graph indicates those 
                characters are being mentioned, while being away from the bottom
                indicates that they not being mentioned. I plan to have
                the characters not currently in the action be shown as
                dashed lines, but that has not implemented yet.
            </p>
            <p>
                The toggle box in the corner moves the characters currently
                present towards the middle, making the lines less tangled. 
                This presently this is somewhat confusing as the red line,
                appears to be present with the other characters 
                when in fact it is merely happens to lie in the center. 
                I plan to have move the characters not presently being mentioned away
                from those that are, but that has not yet been implemented.
            </p>
            <p>
                The plot shown is the top plot on the <a href="./projectsketch.html"> 
                original sketch </a>. It has remained true to it's original purpose,
                though some of the functionality shown has not yet been implemented.
                The bottom plots might change slightly. The bar plot will
                probably made specific to character names, and the line plot may be
                counts of character name by chapter.

            </p>
            
        </div>
    </div>
</div>

</body>
